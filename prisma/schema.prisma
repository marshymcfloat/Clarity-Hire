generator client {
  provider        = "prisma-client"
  output          = "../lib/generated/prisma"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  extensions = [pgvector(map: "vector")]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  id_token          String?
  expires_at        Int?
  token_type        String?
  scope             String?
  session_state     String?
  User              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  // [Bolt] Performance: Index for cascading deletes
  @@index([userId])
}

model Application {
  id                  String              @id @default(cuid())
  userId              String
  jobId               String
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  status              ApplicationStatus   @default(SUBMITTED)
  resumeId            String
  attachmentUrls      String[]            @default([])
  coverLetter         String?
  processedForRAG     Boolean             @default(false)
  ragProcessedAt      DateTime?
  ragProcessingFailed Boolean             @default(false)
  Job                 Job                 @relation(fields: [jobId], references: [id])
  Resume              Resume              @relation(fields: [resumeId], references: [id])
  User                User                @relation(fields: [userId], references: [id])
  ApplicationAnswer   ApplicationAnswer[]

  @@unique([userId, jobId])
  @@index([processedForRAG])
}

model ApplicationAnswer {
  id            String      @id @default(cuid())
  answer        String[]
  applicationId String
  questionId    String
  Application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  Question      Question    @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([applicationId, questionId])
}

model Company {
  id                           String                    @id @default(cuid())
  name                         String
  createdAt                    DateTime                  @default(now())
  updatedAt                    DateTime                  @updatedAt
  coverImage                   String?
  description                  String
  image                        String?
  location                     String
  slug                         String                    @unique
  websiteUrl                   String?
  ownerId                      String                    @unique
  verificationStatus           CompanyVerificationStatus @default(PENDING)
  verificationRequestedAt      DateTime?
  verifiedAt                   DateTime?
  verifiedByUserId             String?
  verificationReason           String?
  suspendedAt                  DateTime?
  suspensionReason             String?
  plan                         String                    @default("free")
  billingStatus                BillingStatus             @default(NONE)
  subscriptionCurrentPeriodEnd DateTime?
  activePublishedJobsLimit     Int?
  stripeCustomerId             String?                   @unique
  companySize                  CompanySize?
  ragQuotaUsed                 Int                       @default(0)
  ragCostMtd                   Float                     @default(0)
  User                         User                      @relation("CompanyOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  VerifiedBy                   User?                     @relation("CompanyVerifiedBy", fields: [verifiedByUserId], references: [id])
  CompanyMember                CompanyMember[]
  Job                          Job[]
  Question                     Question[]
  CandidateAccessLog           CandidateAccessLog[]
  RAGMetrics                   RAGMetrics[]
  AdminAuditLog                AdminAuditLog[]

  @@index([verificationStatus])
  @@index([verifiedByUserId])
  @@index([billingStatus])
}

model CompanyMember {
  id        String   @id @default(cuid())
  userId    String
  companyId String
  role      TeamRole @default(MEMBER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, companyId])
  // [Bolt] Performance: Index for filtering by company and cascading deletes
  @@index([companyId])
}

model Job {
  id                String              @id @default(cuid())
  title             String
  companyId         String
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  department        String
  experienceLevel   ExperienceLevel
  jobType           JobType
  location          String
  salaryMax         Int?
  salaryMin         Int?
  benefits          String[]
  qualifications    String[]
  responsibilities  String[]
  skills            String[]
  workArrangement   WorkArrangement     @default(ON_SITE)
  workSchedule      String?
  summary           String
  status            JobStatus           @default(DRAFT)
  jobEmbeddingId    String?             @unique
  Application       Application[]
  Company           Company             @relation(fields: [companyId], references: [id])
  QuestionOnJob     QuestionOnJob[]
  SavedJob          SavedJob[]
  CandidateJobMatch CandidateJobMatch[]
}

model AdminAuditLog {
  id          String   @id @default(cuid())
  actorUserId String
  action      String
  targetType  String
  targetId    String
  reason      String?
  metadata    Json?
  companyId   String?
  createdAt   DateTime @default(now())
  Actor       User     @relation("AdminActor", fields: [actorUserId], references: [id], onDelete: Cascade)
  Company     Company? @relation(fields: [companyId], references: [id], onDelete: SetNull)

  @@index([actorUserId, createdAt])
  @@index([targetType, targetId])
  @@index([companyId, createdAt])
}

model Question {
  id                String              @id @default(cuid())
  question          String
  companyId         String
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  type              QuestionTypeEnum
  options           String[]
  ApplicationAnswer ApplicationAnswer[]
  Company           Company             @relation(fields: [companyId], references: [id])
  QuestionOnJob     QuestionOnJob[]

  // [Bolt] Performance: Index for filtering by company
  @@index([companyId])
}

model QuestionOnJob {
  jobId      String
  questionId String
  order      Int      @default(0)
  isRequired Boolean  @default(true)
  Job        Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)
  Question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@id([jobId, questionId])
  // [Bolt] Performance: Index for cascading deletes
  @@index([questionId])
}

model Resume {
  id             String          @id @default(cuid())
  name           String
  userId         String
  url            String
  createdAt      DateTime        @default(now())
  deletedAt      DateTime?       @updatedAt
  fileType       String          @default("pdf")
  fileSizeBytes  Int?
  Application    Application[]
  User           User            @relation(fields: [userId], references: [id])
  ParsedDocument ParsedDocument?
}

model SavedJob {
  id        String   @id @default(cuid())
  userId    String
  jobId     String
  createdAt DateTime @default(now())
  Job       Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, jobId])
  // [Bolt] Performance: Index for cascading deletes
  @@index([jobId])
}

// ============================================================
// RAG Models
// ============================================================

model ParsedDocument {
  id            String          @id @default(cuid())
  resumeId      String          @unique
  rawText       String          @db.Text
  textHash      String          @unique
  metadata      Json?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  Resume        Resume          @relation(fields: [resumeId], references: [id], onDelete: Cascade)
  DocumentChunk DocumentChunk[]

  @@index([textHash])
}

model DocumentChunk {
  id             String         @id @default(cuid())
  parsedDocId    String
  position       Int
  chunkIndex     Int
  chunkText      String         @db.Text
  sectionType    String?
  metadata       Json?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  ParsedDocument ParsedDocument @relation(fields: [parsedDocId], references: [id], onDelete: Cascade)
  Embedding      Embedding?

  @@index([parsedDocId, chunkIndex])
  @@index([parsedDocId])
}

model Embedding {
  id             String                     @id @default(cuid())
  chunkId        String                     @unique
  vector         Unsupported("vector(768)") // pgvector type for 768-dimensional embeddings
  contentHash    String
  modelVersionId String
  metadata       Json?
  createdAt      DateTime                   @default(now())
  DocumentChunk  DocumentChunk              @relation(fields: [chunkId], references: [id], onDelete: Cascade)

  @@index([contentHash, modelVersionId])
}

model CandidateJobMatch {
  id             String    @id @default(cuid())
  candidateId    String
  jobId          String
  matchScore     Int
  fitSummary     String?   @db.Text
  pros           String[]
  cons           String[]
  missingReqs    String[]
  evidence       Json?
  interviewKit   Json?
  scoredAt       DateTime  @default(now())
  expiresAt      DateTime?
  isSaved        Boolean   @default(false)
  scoringVersion String
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  Candidate      User      @relation("CandidateJobMatch", fields: [candidateId], references: [id])
  Job            Job       @relation(fields: [jobId], references: [id])

  @@unique([candidateId, jobId])
  @@index([jobId, matchScore])
}

model CandidateAccessLog {
  id           String       @id @default(cuid())
  accessorId   String
  candidateId  String?
  actionType   AccessAction
  resourceType String
  resourceId   String
  companyId    String?
  metadata     Json?
  createdAt    DateTime     @default(now())
  Accessor     User         @relation("Accessor", fields: [accessorId], references: [id])
  Candidate    User?        @relation("CandidateAccessLog", fields: [candidateId], references: [id])
  Company      Company?     @relation(fields: [companyId], references: [id])
}

model RAGMetrics {
  id          String     @id @default(cuid())
  companyId   String?
  metricType  MetricType
  metricValue Float
  metadata    Json?
  createdAt   DateTime   @default(now())
  Company     Company?   @relation(fields: [companyId], references: [id])
}

model User {
  id                 String               @id @default(cuid())
  email              String               @unique
  name               String?
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  role               UserRole             @default(USER)
  username           String?              @unique
  image              String?
  emailVerified      DateTime?
  hashedPassword     String?
  Account            Account[]
  Application        Application[]
  Company            Company?             @relation("CompanyOwner")
  VerifiedCompanies  Company[]            @relation("CompanyVerifiedBy")
  CompanyMember      CompanyMember[]
  Resume             Resume[]
  SavedJob           SavedJob[]
  CandidateJobMatch  CandidateJobMatch[]  @relation("CandidateJobMatch")
  AccessorLogs       CandidateAccessLog[] @relation("Accessor")
  CandidateAccessLog CandidateAccessLog[] @relation("CandidateAccessLog")
  AdminAuditLogs     AdminAuditLog[]      @relation("AdminActor")
}

enum ApplicationStatus {
  SUBMITTED
  IN_REVIEW
  INTERVIEWING
  OFFERED
  REJECTED
  WITHDRAWN
  HIRED
}

enum CompanySize {
  SIZE_1_10
  SIZE_11_50
  SIZE_51_200
  SIZE_201_1000
  SIZE_1000_PLUS
}

enum ExperienceLevel {
  INTERNSHIP
  ENTRY_LEVEL
  ASSOCIATE
  MID_LEVEL
  SENIOR
  STAFF
  PRINCIPAL
}

enum JobStatus {
  DRAFT
  PENDING_REVIEW
  PUBLISHED
  REJECTED
  ARCHIVED
}

enum JobType {
  FULL_TIME
  PART_TIME
  CONTRACT
  INTERNSHIP
}

enum QuestionTypeEnum {
  TEXT
  MULTIPLE_CHOICE
  NUMBER
  CHECKBOX
  TRUE_OR_FALSE
}

enum TeamRole {
  ADMIN
  RECRUITER
  HIRING_MANAGER
  MEMBER
}

enum UserRole {
  USER
  PLATFORM_ADMIN
  OPS_REVIEWER
}

enum CompanyVerificationStatus {
  UNVERIFIED
  PENDING
  VERIFIED
  REJECTED
  SUSPENDED
}

enum BillingStatus {
  NONE
  TRIALING
  ACTIVE
  PAST_DUE
  UNPAID
  CANCELED
  PAUSED
}

enum WorkArrangement {
  ON_SITE
  HYBRID
  REMOTE
}

enum AccessAction {
  SEARCH
  VIEW_RESUME
  DOWNLOAD_RESUME
  VIEW_APPLICATION
  VIEW_PROFILE
  GENERATE_MATCH_REPORT
  SHORTLIST
  REJECT
  INTERVIEW
}

enum MetricType {
  EMBEDDING_GENERATION_COST_USD
  LLM_GENERATION_COST_USD
  VECTOR_DB_COST_USD
  LATENCY_SEMANTIC_SEARCH_MS
  LATENCY_MATCH_GENERATION_MS
  LLM_TOKENS_INPUT
  LLM_TOKENS_OUTPUT
}
